# -*- coding: utf-8 -*-

__author__ = "Przemyslaw Marcowski"
__copyright__ = "Copyright 2024 Przemyslaw Marcowski"
__license__ = "MIT"
__email__ = "p.marcowski@gmail.com"

"""
Module for running a Prisoner's Dilemma Tournament.

This module contains the Tournament class which facilitates the running of a 
full tournament in the Prisoner's Dilemma game, utilizing various strategies among 
agents. It handles the setup of pairings, execution of matches, and summarization 
of results through detailed tables and plots.

Features include handling of noise in decision-making, optional self-play, 
and visualization of strategy effectiveness.
"""

import logging
import matplotlib.pyplot as plt
import numpy as np
from match import Match
from tabulate import tabulate

logger = logging.getLogger(__name__)


class Tournament:
    def __init__(self, agents, num_rounds, self_play=False, noise=0.0):
        """
        Initializes the tournament with a given set of agents and tournament parameters.

        Args:
            agents (list): A list of Agent instances participating in the tournament.
            num_rounds (int): The number of rounds each pair of agents will play 
            against each other. self_play (bool): Allows agents to compete against 
            themselves if True. noise (float): The probability of an agent's action 
            being flipped (C <-> D).
        """
        self.agents = agents
        self.num_rounds = num_rounds
        self.self_play = self_play
        self.noise = noise
        self.matches = []

    def generate_pairings(self):
        """
        Generates all possible pairings of agents for the tournament, considering 
        the self_play option.

        Returns:
            list of tuples: Each tuple represents a pair of agents scheduled to 
            compete.
        """
        if self.self_play:
            return [(agent1, agent2) for agent1 in self.agents for agent2 in self.agents]
        else:
            return [(agent1, agent2) for agent1 in self.agents for agent2 in self.agents if agent1 != agent2]

    def run(self):
        """
        Executes the matches for each pairing generated by generate_pairings method.
        Stores each match's results for further analysis.
        """
        pairings = self.generate_pairings()
        for agent1, agent2 in pairings:
            match = Match(agent1, agent2, self.noise)
            match.run(self.num_rounds)
            self.matches.append(match)

    def analyze_results(self):
        """
        Analyzes and displays the results of all matches from the tournament.
        Outputs include a detailed score table and a plot of average scores.
        """
        scores = {agent.name: [] for agent in self.agents}
        for match in self.matches:
            for score_tuple in match.scores:
                agent1, agent2, score = score_tuple
                scores[agent1.name].append(score[0])
                scores[agent2.name].append(score[1])

        self.display_table(scores)
        self.display_plot(scores)

    def display_table(self, scores):
        """
        Displays a detailed score table showing the average scores per move for 
        each strategy combination. Includes an overall average score for each strategy.

        Args:
            scores (dict): A dictionary of scores categorized by agent names.
        """
        score_matrix = {agent.name: {other_agent.name: [] for other_agent in self.agents} for agent in self.agents}
        for match in self.matches:
            for score_tuple in match.scores:
                agent1, agent2, score = score_tuple
                score_matrix[agent1.name][agent2.name].append(score[0])
                score_matrix[agent2.name][agent1.name].append(score[1])

        headers = ["Strategy"] + [agent.name for agent in self.agents] + ["Overall Average"]
        rows = []
        for strategy, opponents in score_matrix.items():
            row = [strategy]
            total_scores = [score for opponent_scores in opponents.values() for score in opponent_scores if score]
            row.extend(np.mean(opponents[opponent.name]) if opponents[opponent.name] else "-" for opponent in self.agents)
            row.append(np.mean(total_scores) if total_scores else "-")
            rows.append(row)

        table = tabulate(rows, headers=headers, tablefmt="github", floatfmt=".2f", missingval="-")
        logger.info("Average Scores per Move for Each Strategy Combination:")
        print(table)

    def display_plot(self, scores):
        """
        Displays a bar plot of the average scores per strategy based on the 
        tournament results.

        Args:
            scores (dict): A dictionary containing the average scores per strategy.
        """
        names = list(scores.keys())
        values = [np.mean(scores[name]) for name in names if scores[name]]

        fig, ax = plt.subplots()
        ax.bar(names, values, color='skyblue')
        ax.set_ylabel('Average Score per Move')
        ax.set_title('Average Scores per Strategy')
        ax.set_xticks(np.arange(len(names)))
        ax.set_xticklabels(names, rotation=45)
        plt.tight_layout()
        plt.show()
